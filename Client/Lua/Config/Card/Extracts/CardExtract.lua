---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zheng.
--- DateTime: 2019/3/14 23:05
--- 牌型提取器
---
---@class
local CardGroup = require("Game.Config.Card.CardGroup")
local LuaObject = require('Betel.LuaObject')
---@class Game.Config.Card.Extracts.CardExtract : Betel.LuaObject
---@field New function<cards : table<number, Game.Config.Card.CardBaseVo>>
---@field cards table<number, Game.Config.Card.CardBaseVo>
local CardExtract = class("Game.Config.Card.Extracts.CardExtract",LuaObject)

---@param cards table<number, Game.Config.Card.CardBaseVo>
function CardExtract:Ctor(cards)
    self.cards = cards
    self.cardNum = #cards
    self._hashSet = nil
    self._suitHashSet = nil
    self._array = nil
    self._sortKeys = nil
end

function CardExtract:getHashSet()
    if  self._hashSet == nil then
        self._hashSet = {}
        for i = 1, self.cardNum do
            local fv = self.cards[i].faceValue
            local num = self._hashSet[fv]
            self._hashSet[fv] = (num == nil) and 1 or num + 1
        end
    end
    return self._hashSet
end

function CardExtract:getSuitHashSet()
    if  self._suitHashSet == nil then
        self._suitHashSet = {}
        for i = 1, self.cardNum do
            local s = self.cards[i].suit
            local num = self._suitHashSet[s]
            self._suitHashSet[s] = (num == nil) and 1 or num + 1
        end
    end
    return self._suitHashSet
end

--获取牌的点数数组
function CardExtract:geyArray()
    if  self._array == nil then
        self._array = {}
        for i = 1, self.cardNum do
            table.insert(self._array,self.cards[i].faceValue)
        end
    end
    return self._array
end

--根据键值 升序
function CardExtract:getHashSetSortByKey()
    if self._sortKeys == nil then
        self._sortKeys = {}
        local hashSet = self:getHashSet()
        for fv,num in pairs(hashSet) do
            table.insert(self._sortKeys,{fv = fv,num = num})
        end
        table.sort(self._sortKeys, function(v1, v2)
            return v1.fv < v2.fv
        end)
    end
    return self._sortKeys
end

--根据数量 降序
function CardExtract:getHashSetSortByNum()
    if self._sortNums == nil then
        self._sortNums = {}
        local hashSet = self:getHashSet()
        for fv,num in pairs(hashSet) do
            table.insert(self._sortNums,{fv = fv,num = num})
        end
        table.sort(self._sortNums, function(v1, v2)
            return v1.num > v2.num
        end)
    end
    return self._sortNums
end

---@return boolean
function CardExtract:isSingle()
    if self.cardNum == 1 then
        return true
    else
        return false
    end
end

---@return boolean
function CardExtract:isDouble()
    if self.cardNum == 2 and self.cards[1].faceValue == self.cards[2].faceValue then
        return true
    else
        return false
    end
end

--是否同花
---@return boolean
function CardExtract:isSameSuit()
    local suitHashSet = self:getSuitHashSet()
    local suitNum = 0
    for i, v in pairs(suitHashSet) do
        suitNum = suitNum + 1
    end
    return suitNum == 1
end

--是否多带多
---@param size number
---@param maxTakeNum number 带的最大数量
---@return boolean
function CardExtract:isTakeN(size, maxTakeNum)
    if self.cardNum <= size + maxTakeNum then
        local sortNums = self:getHashSetSortByNum()
        if sortNums[1].num == size then
            return true
        else
            return false
        end
    else
        return false
    end
end

--是否是顺子
---@param size number 顺子数量
---@param minContinuousNum number 最小连续数量
---@return boolean
function CardExtract:isStraight(size, minContinuousNum)
    local num = self.cardNum / size
    if num >= minContinuousNum then--数量是否符合
        local sortKeys = self:getHashSetSortByKey()
        local diff = Mathf.Abs(sortKeys[1].fv - sortKeys[#sortKeys].fv)
        if #sortKeys == num and diff == num - 1 then
            return true
        else
            return false
        end
    else
        return false
    end
end

--多级顺子，且可以带若干数量的杂牌
---@param size number 顺子数量
---@param minContinuousNum number 最小连续数量
---@param maxTakeNum number 最大可带数量
---@return boolean, number
function CardExtract:getMultiStraightInfo(size, minContinuousNum, maxTakeNum)
    local sortNums = self:getHashSetSortByNum()
    local continuousNum = 0;
    for i = 1, #sortNums do
        if sortNums[i].num == size then
            continuousNum = continuousNum + 1
        end
    end
    if continuousNum >= minContinuousNum then
        local sortKeys = self:getHashSetSortByKey()
        local diff = Mathf.Abs(sortKeys[1].fv - sortKeys[continuousNum].fv)
        if diff == continuousNum - 1 then
            --带的数量异常
            if self.cardNum > continuousNum * size + maxTakeNum then
                return false
            end
            return true,continuousNum
        else
            return false,0
        end
    else
        return false,0
    end
end

return CardExtract
