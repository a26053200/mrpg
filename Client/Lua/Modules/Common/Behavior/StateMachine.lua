---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhengnan.
--- DateTime: 2019/5/20 15:50
--- 状态机
---

local StateAction = require("Game.Modules.Common.Behavior.StateAction")

---@class Game.Modules.Common.Behavior.StateMachine
---@field New fun(node:StateNode):Game.Modules.Common.Behavior.StateMachine
---@field currState Game.Modules.Common.Behavior.StateAction
---@field startTime number 开始时间
local StateMachine = class("Game.Modules.Common.Behavior.StateMachine")

local s_id = 1

function StateMachine:Ctor()

    self.id = s_id
    s_id = s_id + 1

    self.stateMap = {}
    self.state2DList = List.New() --状态二维表
    self.currState = nil
    self.currStateList = self.state2DList
    self.cycleOverCallback = nil --周期结束
    self.isDispose = false
    self.curr2DList = nil
end

function StateMachine:Start(cycleOverCallback)
    self.cycleOverCallback = cycleOverCallback
    self.currState = nil
    self.curr2DList = self.state2DList:Clone()
    AddEventListener(Event.Update, self.Update, self)
end

function StateMachine:Stop()
    self.currStateIndex = 0
    self.currState = nil
    RemoveEventListener(Event.Update, self.Update, self)
end

function StateMachine:BeginSelect()
    self.currStateList = List.New()
end

---@param stateAction Game.Modules.Common.Behavior.StateAction
function StateMachine:AppendState(stateAction)
    self.currStateList:Push(stateAction)
end

function StateMachine:EndSelect()
    self.state2DList:Push(self.currStateList)
    self.currStateList = self.state2DList
end

function StateMachine:NextState()
    if self.curr2DList:Size() == 0 then
        self.curr2DList = self.state2DList:Clone()
        if self.cycleOverCallback then
            self.cycleOverCallback()
        end
    end
    local state = self.curr2DList:Shift()
    if state._cname == StateAction._cname then
        self.currState = state
    elseif state._cname == List._cname then
        --随机选择 (这个地方有待优化)
        local randomIdx = math.random(1, state:Size())
        self.currState = state[randomIdx]
        while not self.currState:CanExecute() do
            randomIdx = math.random(1, state:Size())
            self.currState = state[randomIdx]
        end
    else
        logError("State machine queue error!!!")
    end
    self.currState:Start()
end

function StateMachine:Update()
    if self.currState then
        local state = self.currState
        local isOver = state:IsOver()
        if not state.execute and state.node.OnEnter ~nil then
            state.execute = true
            state.node.OnEnter:Execute(state)
        end
        if isOver then
            self:NextState()
        end
    end
end

return StateMachine